#!/bin/bash

# GitLab CI/CD Configuration Script for SageMaker ML Pipeline
# This script configures a complete GitLab CI/CD pipeline with S3 artifact compression
# Author: Generated for GitLab-SageMaker-CICD-For-ML-Training-and-Hosting
# Date: $(date)

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Global variables
GITLAB_IP=""
GITLAB_URL=""
GITLAB_TOKEN=""
PROJECT_ID=""
AWS_ACCOUNT_ID=""
RUNNER_TOKEN=""

# Logging function
log() {
    echo -e "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log_info() {
    log "${BLUE}INFO${NC}: $1"
}

log_success() {
    log "${GREEN}SUCCESS${NC}: $1"
}

log_warning() {
    log "${YELLOW}WARNING${NC}: $1"
}

log_error() {
    log "${RED}ERROR${NC}: $1"
}

# Error handling
error_exit() {
    log_error "$1"
    exit 1
}

# Function to check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    # Check if OpenTofu is available
    if ! command -v tofu &> /dev/null; then
        error_exit "OpenTofu is not installed or not in PATH"
    fi
    # Check if AWS CLI is available
    if ! command -v aws &> /dev/null; then
        error_exit "AWS CLI is not installed or not in PATH"
    fi
    # Check if curl is available
    if ! command -v curl &> /dev/null; then
        error_exit "curl is not installed or not in PATH"
    fi

    # Check if jq is available
    if ! command -v jq &> /dev/null; then
        error_exit "jq is not installed or not in PATH"
    fi
    
    # Check if SSH key exists
    if [ ! -f ~/.ssh/id_rsa ]; then
        error_exit "SSH key not found at ~/.ssh/id_rsa"
    fi
    log_success "Prerequisites check passed"
}

# Function to get GitLab information from OpenTofu
get_gitlab_info() {
    log_info "Getting GitLab information from OpenTofu outputs..."
    
    # Debug: Show current directory and tofu status
    log_info "Current directory: $(pwd)"
    log_info "OpenTofu version: $(tofu version 2>/dev/null || echo 'tofu not available')"
    
    # Get GitLab public IP with detailed debugging
    log_info "Attempting to get gitlab_public_ip from OpenTofu..."
    GITLAB_IP=$(tofu output -raw gitlab_public_ip 2>&1)
    if [ $? -eq 0 ] && [ -n "$GITLAB_IP" ]; then
        log_success "GitLab public IP from OpenTofu: $GITLAB_IP"
    else
        log_error "Failed to get GitLab public IP from OpenTofu. Output: $GITLAB_IP"
        error_exit "Could not get GitLab public IP from OpenTofu outputs"
    fi
    
    GITLAB_URL="http://$GITLAB_IP"
    log_success "GitLab URL set to: $GITLAB_URL"
    
    # Get AWS account ID with debugging
    log_info "Getting AWS account ID..."
    AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text 2>&1)
    if [ $? -eq 0 ] && [ -n "$AWS_ACCOUNT_ID" ]; then
        log_success "AWS Account ID: $AWS_ACCOUNT_ID"
    else
        log_error "Failed to get AWS Account ID. Output: $AWS_ACCOUNT_ID"
        error_exit "Could not get AWS Account ID"
    fi
}

# Function to verify GitLab is accessible
verify_gitlab_access() {
    log_info "Verifying GitLab server accessibility..."
    
    # Test HTTP connectivity with detailed debugging
    log_info "Testing HTTP connectivity to $GITLAB_URL..."
    HTTP_RESPONSE=$(curl -s -w "%{http_code}" --connect-timeout 10 "$GITLAB_URL" 2>&1)
    HTTP_STATUS=${HTTP_RESPONSE: -3}
    
    if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "302" ] || [ "$HTTP_STATUS" = "401" ]; then
        log_success "GitLab HTTP connectivity successful. Status: $HTTP_STATUS"
    else
        log_error "GitLab HTTP connectivity failed. Status: $HTTP_STATUS, Response: ${HTTP_RESPONSE%???}"
        error_exit "GitLab server is not accessible at $GITLAB_URL"
    fi
    
    # Test SSH connectivity with detailed debugging
    log_info "Testing SSH connectivity to $GITLAB_IP..."
    if ssh -i ~/.ssh/id_rsa -o ConnectTimeout=10 -o StrictHostKeyChecking=no ubuntu@$GITLAB_IP "echo 'SSH test successful'" 2>&1; then
        log_success "SSH connectivity to GitLab server verified"
    else
        SSH_ERROR=$?
        log_error "SSH connectivity to GitLab server failed with exit code: $SSH_ERROR"
        error_exit "SSH connectivity to GitLab server failed"
    fi
}

# Function to create GitLab personal access token
create_access_token() {
    log_info "Creating GitLab personal access token..."
    TIMESTAMP=$(date +%s)
    GITLAB_TOKEN=$(ssh -i ~/.ssh/id_rsa ubuntu@$GITLAB_IP "sudo gitlab-rails runner \"user = User.find_by(username: 'root'); token = user.personal_access_tokens.create(scopes: ['api', 'read_user', 'read_repository', 'write_repository'], name: 'ci-setup-token-$TIMESTAMP', expires_at: 30.days.from_now); puts 'Token: ' + token.token if token.persisted?; puts 'Errors: ' + token.errors.full_messages.join(', ') unless token.persisted?\"" 2>/dev/null | grep "Token:" | cut -d' ' -f2)
    if [ -z "$GITLAB_TOKEN" ]; then
        error_exit "Failed to create GitLab access token"
    fi
    log_success "GitLab access token created"
}

# Function to create or get GitLab project
setup_gitlab_project() {
    log_info "Setting up GitLab project..."
    # Try to get existing project first
    PROJECT_RESPONSE=$(curl -s -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$GITLAB_URL/api/v4/projects" | jq -r '.[] | select(.name == "training-job-cicd-demo")')
    
    if [ -n "$PROJECT_RESPONSE" ]; then
        PROJECT_ID=$(echo "$PROJECT_RESPONSE" | jq -r '.id')
        log_success "Found existing GitLab project with ID: $PROJECT_ID"
    else
        # Create new project
        PROJECT_RESPONSE=$(curl -s -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$GITLAB_URL/api/v4/projects" -X POST -d "name=training-job-cicd-demo&visibility=private&initialize_with_readme=false" | jq -r '.')
        PROJECT_ID=$(echo "$PROJECT_RESPONSE" | jq -r '.id')
        
        if [ -z "$PROJECT_ID" ] || [ "$PROJECT_ID" == "null" ]; then
            error_exit "Failed to create GitLab project. Response: $PROJECT_RESPONSE"
        fi
        log_success "Created GitLab project with ID: $PROJECT_ID"
    fi
}

# Function to configure CI/CD variables
configure_cicd_variables() {
    log_info "Configuring GitLab CI/CD variables..."
    # Get S3 bucket names from OpenTofu
    local ARTIFACTS_BUCKET=$(tofu output -raw gitlab_artifacts_bucket_name)
    local RELEASES_BUCKET=$(tofu output -raw gitlab_releases_bucket_name)
    local CI_ROLE_ARN=$(tofu output -raw gitlab_ci_iam_role_arn)
    
    # Array of variables to set
    declare -A variables
    variables["AWS_DEFAULT_REGION"]="us-east-1"
    variables["AWS_ACCOUNT_ID"]="$AWS_ACCOUNT_ID"
    variables["SAGEMAKER_ROLE_ARN"]="arn:aws:iam::$AWS_ACCOUNT_ID:role/SageMakerExecutionRole"
    variables["S3_BUCKET"]="ml-training-data-$AWS_ACCOUNT_ID"
    variables["GITLAB_ARTIFACTS_BUCKET"]="$ARTIFACTS_BUCKET"
    variables["GITLAB_RELEASES_BUCKET"]="$RELEASES_BUCKET"
    variables["MODEL_PACKAGE_GROUP_NAME"]="ml-models"
    variables["PYTHON_VERSION"]="3.8"
    variables["AWS_ROLE_ARN"]="$CI_ROLE_ARN"
    
    # Fetch existing variables to avoid recreating and only update if necessary
    local EXISTING_VARIABLES_RAW=$(curl -s -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$GITLAB_URL/api/v4/projects/$PROJECT_ID/variables" | jq -r '.[] | {key: .key, value: .value}' || echo "[]")
    
    for key in "${!variables[@]}"; do
        local VALUE="${variables[$key]}"
        local VAR_EXISTS=$(echo "$EXISTING_VARIABLES_RAW" | jq -r '.[] | select(.key == "'"$key"'") | .key // empty' 2>/dev/null)
        local VAR_CURRENT_VALUE=$(echo "$EXISTING_VARIABLES_RAW" | jq -r '.[] | select(.key == "'"$key"'") | .value // empty' 2>/dev/null)
        
        if [ -n "$VAR_EXISTS" ]; then
            if [ "$VAR_CURRENT_VALUE" != "$VALUE" ]; then
                # Update existing variable if value is different
                RESPONSE=$(curl -s -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$GITLAB_URL/api/v4/projects/$PROJECT_ID/variables/$key" -X PUT -d "value=$VALUE&protected=false")
                if echo "$RESPONSE" | grep -q '"key"'; then
                    log_success "Updated variable: $key"
                else
                    log_warning "Failed to update variable: $key. Response: $RESPONSE"
                fi
            else
                log_info "Variable $key already up-to-date."
            fi
        else
            # Create new variable
            RESPONSE=$(curl -s -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$GITLAB_URL/api/v4/projects/$PROJECT_ID/variables" -X POST -d "key=$key&value=$VALUE&protected=false")
            if echo "$RESPONSE" | grep -q '"key"'; then
                log_success "Set variable: $key"
            else
                log_warning "Failed to set variable: $key. Response: $RESPONSE"
            fi
        fi
    done
}

# Function to install and configure GitLab runner
setup_gitlab_runner() {
    log_info "Setting up GitLab Runner..."
    
    # Check if runner is already installed with debugging
    log_info "Checking if GitLab Runner is already installed..."
    if ssh -i ~/.ssh/id_rsa ubuntu@$GITLAB_IP "command -v gitlab-runner" 2>&1; then
        log_success "GitLab Runner is already installed"
    else
        log_info "Installing GitLab Runner..."
        # Install GitLab Runner with detailed output
        log_info "Running installation commands on GitLab server..."
        INSTALL_OUTPUT=$(ssh -i ~/.ssh/id_rsa ubuntu@$GITLAB_IP "
            echo 'Updating package lists...'
            sudo apt-get update
            echo 'Installing GitLab Runner...'
            curl -L \"https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh\" | sudo bash
            sudo apt-get install gitlab-runner -y
            echo 'Installation completed.'
        " 2>&1)
        
        if [ $? -eq 0 ]; then
            log_success "GitLab Runner installed successfully"
            log_info "Installation output: $INSTALL_OUTPUT"
        else
            log_error "Failed to install GitLab Runner. Output: $INSTALL_OUTPUT"
            error_exit "Failed to install GitLab Runner"
        fi
    fi
    
    # Get runner token with debugging
    log_info "Getting GitLab runner token..."
    RUNNER_TOKEN=$(curl -s -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$GITLAB_URL/api/v4/projects/$PROJECT_ID" | jq -r '.runners_token')
    if [ -z "$RUNNER_TOKEN" ] || [ "$RUNNER_TOKEN" == "null" ]; then
        RAW_RESPONSE=$(curl -s -H "PRIVATE-TOKEN: $GITLAB_TOKEN" "$GITLAB_URL/api/v4/projects/$PROJECT_ID")
        log_error "Failed to get GitLab runner token. Response: $RAW_RESPONSE"
        error_exit "Failed to get GitLab runner token"
    fi
    log_success "Runner token obtained: ${RUNNER_TOKEN:0:10}..."
    
    # Register runner if not already registered with debugging
    log_info "Checking if runner is already registered..."
    REGISTERED=$(ssh -i ~/.ssh/id_rsa ubuntu@$GITLAB_IP "sudo gitlab-runner list | grep -q 'SageMaker CI/CD Runner'; echo \$?" 2>/dev/null)
    
    if [ "$REGISTERED" -ne 0 ]; then
        log_info "Registering GitLab Runner..."
        REGISTER_OUTPUT=$(ssh -i ~/.ssh/id_rsa ubuntu@$GITLAB_IP "
            echo 'Registering GitLab Runner...'
            sudo gitlab-runner register --non-interactive \
                --url $GITLAB_URL \
                --registration-token $RUNNER_TOKEN \
                --executor shell \
                --description 'SageMaker CI/CD Runner' \
                --tag-list 'sagemaker,ml,cicd' \
                --run-untagged='true' \
                --locked='false'
            echo 'Registration completed.'
        " 2>&1)
        
        if [ $? -eq 0 ]; then
            log_success "GitLab Runner registered successfully"
            log_info "Registration output: $REGISTER_OUTPUT"
        else
            log_error "Failed to register GitLab Runner. Output: $REGISTER_OUTPUT"
            error_exit "Failed to register GitLab Runner"
        fi
    else
        log_success "GitLab Runner already registered"
    fi
    
    # Start and enable runner with debugging
    log_info "Starting and enabling GitLab Runner service..."
    SERVICE_OUTPUT=$(ssh -i ~/.ssh/id_rsa ubuntu@$GITLAB_IP "
        sudo gitlab-runner start
        sudo systemctl enable gitlab-runner
        echo 'Service status:'
        sudo systemctl status gitlab-runner --no-pager -l
    " 2>&1)
    
    if [ $? -eq 0 ]; then
        log_success "GitLab Runner service started and enabled"
        log_info "Service output: $SERVICE_OUTPUT"
    else
        log_warning "Failed to start/enable GitLab Runner. Output: $SERVICE_OUTPUT"
    fi
}

# Function to install required tools on GitLab server
install_required_tools() {
    log_info "Installing required tools on GitLab server..."
    # Check and install AWS CLI
    if ! ssh -i ~/.ssh/id_rsa ubuntu@$GITLAB_IP "command -v aws" &> /dev/null; then
        log_info "Installing AWS CLI..."
        ssh -i ~/.ssh/id_rsa ubuntu@$GITLAB_IP "
            sudo apt-get update && \
            sudo apt-get install unzip -y && \
            curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip && \
            unzip -q awscliv2.zip && \
            sudo ./aws/install && \
            rm -rf aws*
        " || error_exit "Failed to install AWS CLI"
        log_success "AWS CLI installed"
    else
        log_success "AWS CLI already installed"
    fi

    # Check and install jq
    if ! ssh -i ~/.ssh/id_rsa ubuntu@$GITLAB_IP "command -v jq" &> /dev/null; then
        log_info "Installing jq..."
        ssh -i ~/.ssh/id_rsa ubuntu@$GITLAB_IP "sudo apt-get update && sudo apt-get install -y jq" || error_exit "Failed to install jq"
        log_success "jq installed"
    else
        log_success "jq already installed"
    fi
    
    # Verify AWS CLI can access with IAM role
    if ssh -i ~/.ssh/id_rsa ubuntu@$GITLAB_IP "/usr/local/bin/aws sts get-caller-identity" &> /dev/null; then
        log_success "AWS CLI configured and working with IAM role"
    else
        log_warning "AWS CLI may not be properly configured"
    fi
}

# Function to test S3 bucket access
test_s3_access() {
    log_info "Testing S3 bucket access..."
    ARTIFACTS_BUCKET=$(tofu output -raw gitlab_artifacts_bucket_name)
    RELEASES_BUCKET=$(tofu output -raw gitlab_releases_bucket_name)
    # Test artifacts bucket
    if aws s3 ls "s3://$ARTIFACTS_BUCKET/" &> /dev/null; then
        log_success "Artifacts bucket accessible: $ARTIFACTS_BUCKET"
    else
        log_warning "Artifacts bucket may not be accessible: $ARTIFACTS_BUCKET"
    fi
    # Test releases bucket
    if aws s3 ls "s3://$RELEASES_BUCKET/" &> /dev/null; then
        log_success "Releases bucket accessible: $RELEASES_BUCKET"
    else
        log_warning "Releases bucket may not be accessible: $RELEASES_BUCKET"
    fi
    # Test write access by creating a test file
    TEST_FILE="/tmp/gitlab-cicd-test-$(date +%s).txt"
    echo "GitLab CI/CD test file created at $(date)" > "$TEST_FILE"
    if aws s3 cp "$TEST_FILE" "s3://$ARTIFACTS_BUCKET/test/" &> /dev/null; then
        log_success "S3 write access verified"
        aws s3 rm "s3://$ARTIFACTS_BUCKET/test/$(basename $TEST_FILE)" &> /dev/null || true
    else
        log_warning "S3 write access may be limited"
    fi
    rm -f "$TEST_FILE"
}

# Function to ensure root password exists
ensure_root_password() {
    log_info "Ensuring GitLab root password exists..."
    # Check if initial password file exists
    if ssh -i ~/.ssh/id_rsa ubuntu@$GITLAB_IP "sudo test -f /etc/gitlab/initial_root_password" 2>/dev/null; then
        log_success "Initial root password file exists"
        return 0
    fi
    log_info "Initial root password file not found, creating new password..."
    # Generate a secure password (avoid common words)
    ROOT_PASSWORD="$(openssl rand -hex 8 | tr '[:lower:]' '[:upper:]')$(date +%s | tail -c4)!"
    # Set the root password via Rails console
    ssh -i ~/.ssh/id_rsa ubuntu@$GITLAB_IP "sudo gitlab-rails runner \" user = User.find_by(username: 'root') if user user.password = '$ROOT_PASSWORD' user.password_confirmation = '$ROOT_PASSWORD' if user.save puts 'Password set successfully' else puts 'Password set failed: ' + user.errors.full_messages.join(', ') exit 1 end else puts 'Root user not found' exit 1 end \"" 2>/dev/null || error_exit "Failed to set root password"
    # Create password file for reference
    ssh -i ~/.ssh/id_rsa ubuntu@$GITLAB_IP "sudo tee /etc/gitlab/initial_root_password > /dev/null << EOF
# GitLab initial root password
# Generated by configure-gitlab-cicd script
Username: root
Password: $ROOT_PASSWORD
# This file was created because the original was missing
# You can safely delete this file after noting the password
EOF" 2>/dev/null || log_warning "Could not create password file"
    log_success "Root password created: $ROOT_PASSWORD"
    log_info "Password saved to: /etc/gitlab/initial_root_password"
}

# Configuration complete - use launch-train-job.sh to deploy training repository
# Main execution function
main() {
    echo "======================================"
    echo "GitLab CI/CD Configuration for SageMaker"
    echo "======================================"
    echo ""
    # Change to project root
    cd "$PROJECT_ROOT"
    # Execute configuration steps
    check_prerequisites
    get_gitlab_info
    verify_gitlab_access
    ensure_root_password
    create_access_token
    setup_gitlab_project
    configure_cicd_variables
    setup_gitlab_runner
    install_required_tools
    test_s3_access
    echo ""
    echo -e "${GREEN}✅ GitLab CI/CD Infrastructure Ready!${NC}"
    echo ""
    echo "Configuration Summary:"
    echo " \033[0;32m•\033[0m URL: $GITLAB_URL"
    echo " \033[0;32m•\033[0m Project ID: $PROJECT_ID"
    echo " \033[0;32m•\033[0m Project: training-job-cicd-demo"
    echo ""
    echo "Next Step:"
    echo " Run training job launcher: ./server-scripts/launch-train-job.sh $GITLAB_IP $GITLAB_URL $GITLAB_TOKEN $PROJECT_ID training-job-cicd-demo"
    echo ""
    log_success "GitLab CI/CD configuration completed successfully!"
}

# Script execution
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi
